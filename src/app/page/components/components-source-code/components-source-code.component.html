<h4>Source viewer</h4>
<p>
  This site shows a lot of source code which is running this site.
</p>
<p>
  To achieve this, I'm using a script to generate HTML friendly files from
  actual sources. Later on, these files are displayed by a component, designed
  specifically for this task.
</p>
<p>
  To see updates during development I'm using the
  <a [routerLink]="utilitiesConcurrentlyPath">concurrently</a> utility.
</p>
<h5 id="{{ descriptionAnchor }}">Description</h5>
<p>
  The component combines navigation
  <a [routerLink]="componentsTabsPath">tabs</a> and code viewer and leverages
  the
  <app-external-link [href]="bootstrapUrl">bootstrap's</app-external-link>
  carousel layout.
</p>
<p>Here are the sources of the component:</p>
<app-source-viewer [sources]="sourceViewerSources"></app-source-viewer>
<h5 id="{{ sourcesAnchor }}">Sources</h5>
<p>
  The component relies on data stored in the JSON file named
  <code>sources.json</code>.
</p>
<p>
  The file stores descriptions of the HTML friendly files.
</p>
<p>
  The descriptions are following the next convention - the key is the name of a
  file in the lowerCamelCase format.
</p>
<p>
  The description object contains two fields:
</p>
<ol>
  <li>The relative path to the source file.</li>
  <li>The hash-name of the HTML friendly file.</li>
</ol>
<p>
  For example, I want to add a <code>button-positive.component.ts</code> file to
  the list of sources.
</p>
<p>
  It will look like:
</p>
<app-code>{{ addToSourcesJsonCode }}</app-code>
<app-note>
  Notice that there is no hash-name at this point. The hash-name can be defined
  manually or by <code>sources.js</code> script during processing the
  <code>sources.json</code>.
</app-note>
<p>Later on, in this case, the description after processing will look like:</p>
<app-code>{{ sourcesJsonAfterProcessingCode }}</app-code>
<app-note
  >The hash-names are automatically generated by the code similar to the
  <a [routerLink]="idServicePath">idService</a>.</app-note
>
<p>
  Hash-names are used to avoid name collision. Thus, it is possible to include
  files with a similar name.
</p>
<h5 id="{{ processingAnchor }}">Processing</h5>
<p>
  Files listed in the <code>sources.json</code> are processed by
  <code>sources.js</code> script, which works in
  <app-external-link [href]="nodeJsUrl">Node.js</app-external-link> environment.
</p>
<p>
  The script is started during the development phase, as well as the building
  phase.
</p>
<app-note
  >About using the script during the development read
  <a [routerLink]="utilitiesConcurrentlyPath">here</a>.</app-note
>
<p>
  The build script in the <code>package.json</code> file is modified to process
  files listed in <code>sources.json</code> before building the project.
</p>
<app-code>{{ buildScriptCode }}</app-code>
<p>
  The processed files are placed into the <cite>assets</cite> folder into the
  subfolder named <cite>sources</cite>. The <cite>assets</cite> folder is
  statically served by
  <app-external-link [href]="angularUrl">Angular</app-external-link> in
  run-time.
</p>
<app-source-viewer [sources]="sourcesJsSources"></app-source-viewer>
<p>
  The processing script is indeed simple.
</p>
<ol>
  <li>Read the sources list from <code>sources.json</code>.</li>
  <li>
    Empty the <cite>sources</cite> subfolder in the
    <cite>assets</cite> directory.
  </li>
  <li>
    Process files in the loop.
  </li>
</ol>
<p>
  The processing can be described by these steps:
</p>
<p>
  After the source description is extracted from the list, the script updates
  the progress output.
</p>
<p>
  On the next step, the script checks the hash-name value and defines it if
  necessary.
</p>
<p>
  Later, the file contents are converted into the string, and symbols
  <b>&amp;</b>, <b>&lt;</b> and <b>&gt;</b> are replaced with HTML entities.
</p>
<p>
  Finally, the result is saved in the file with hash-name into the sources
  folder.
</p>
<app-note
  >Additional data modifications can be applied during file processing. For
  example, keyword coloration or syntax highlight.</app-note
>
<h5 id="{{ renderingAnchor }}">Rendering</h5>
<p>
  To render the source files, I'm defining the settings via
  <code>SourceViewer</code> type.
</p>
<p>
  Here is an example:
</p>
<app-code>{{ sourceViewerSettingsCode }}</app-code>
<p>
  Here is an explanation for the input parameters of the underlying
  <code>ISourceViewer</code> interface.
</p>
<p>
  To simplify the process of the settings declaration, the given interface
  follows several conventions.
</p>
<p>
  If the <code>id</code> parameter is provided, it will be used as-is, and the
  component will try to find the exact match in <code>sources.json</code>.
</p>
<p>
  The named parameter <code>component</code> will be converted into the set of
  parameters.
</p>
<p>
  These settings:
</p>
<app-code>{{ sourceViewerSettingsSampleCode }}</app-code>
<p>
  Will be converted into:
</p>
<ul>
  <li>sourceViewerComponentHtml</li>
  <li>sourceViewerComponentScss</li>
  <li>sourceViewerComponentTs</li>
  <li>sourceViewerModuleTs</li>
</ul>
<p>
  Such rules are also defined for the rest of the named parameters of this
  interface. They can be found in the definition of the interface.
</p>
<p>
  After the appropriate module is added to the imports section the component can
  be used as follows:
</p>
<app-code>{{ sourceViewerImplementationCode }}</app-code>
<h5 id="{{ conclusionAnchor }}">Conclusion</h5>
<p>
  The source viewer component consists of three parts:
</p>
<ul>
  <li>
    The script to process files.
  </li>
  <li>
    The files description list.
  </li>
  <li>
    The source rendering component.
  </li>
</ul>
<p>
  The processing script and the rendering component are both relying on the
  description list.
</p>
<p>
  This solution can be used during development and in build time.
</p>
<p><strong>Pros</strong>:</p>
<ul>
  <li>
    The solution is lightweight.
  </li>
  <li>
    It works lighting-fast.
  </li>
  <li>
    All changes to the source code are reflected in the processed files upon
    save.
  </li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
  <li>
    The list must be kept in sync manually.
  </li>
</ul>
