<h4>Button</h4>
<p>The button is one of the most usable interactive UI building blocks.</p>
<p>
  Buttons can be
  <app-button [disabled]="true" [style]="bsBtnDark">disabled</app-button>,
  contain an <app-button><fa-icon [icon]="faIcons"></fa-icon> icon</app-button>,
  be
  <app-button [style]="bsBtnWarning" [size]="bsBtnSizeLarge">LARGE</app-button>
  or
  <app-button [style]="bsBtnDanger" [size]="bsBtnSizeSmall">small</app-button>,
  etc.
</p>
<p>So, the number of use cases for such a simple element is innumerable.</p>
<p>
  All this power hides behind a simple tag:
</p>
<app-code>{{ buttonCode }}</app-code>
<p>
  The simplest way to achieve this goal is to create a set of wrapping classes.
  Thus the only thing you'll need is to insert a button into the template and
  define its behavior.
</p>
<p>
  What will these classes do? For the most part, they will provide you a ready
  to use component with all the required styles applied. Also, you can predefine
  some logic, for example, create a toggle button.
</p>
<p>Let's have a look at the base class one can use.</p>
<app-source-viewer [sources]="buttonSources"></app-source-viewer>
<p>The design of this class is simple and minimalistic.</p>
<h5 [id]="templateAnchor">Template</h5>
<p>
  The template contains a simple HTML button component as its base. The
  <code>button</code> tag contains an id, a CSS class definition based on
  settings, and a dynamic CSS class to track disabled state.
</p>
<h5 [id]="styleAnchor">Style</h5>
<p>
  Style definitions are minimal and containing only the most basic settings. For
  the most part, they are adding <code>cursor</code> pointer and removing
  <code>pointer-events</code> in disabled mode. The rest of the style
  definitions are
  <app-external-link [href]="bootstrapUrl">Bootstrap</app-external-link>.
</p>
<h5 [id]="componentAnchor">Component</h5>
<p>
  The component contains several input interfaces: an id, a style, a size, and a
  disabled state. Some of the interfaces have a default value.
</p>
<p>
  The only tricky part of the component is a <code>checkDisabled</code> method.
  Because a click event is applied directly to the shadow DOM element, this
  method affects the <code>pointer-events</code> of the host element.
</p>
<h5 [id]="moduleAnchor">Module</h5>
<p>
  The module of this component contains only the required definitions and
  imports.
</p>
<h5 [id]="exampleAnchor">Example</h5>
<p>Let's assume that some project requires a set of ready to use buttons.</p>
<p>
  Among this set, there could be a default button for all positive cases. E.g.
  like submit, ok, agree, etc.
</p>
<p>
  And it should look like this:
  <app-button-positive>Submit</app-button-positive>,
  <app-button-positive>Ok</app-button-positive>,
  <app-button-positive>Agree</app-button-positive>.
</p>
<p>Here is the code:</p>
<app-source-viewer [sources]="buttonPositiveSources"></app-source-viewer>
<p>
  This way, a project can easily have any set of predefined components. Later
  on, one can use it as follows:
</p>
<app-code>{{ buttonPositiveExampleCode }}</app-code>
<h5 [id]="conclusionAnchor">Conclusion</h5>
<p>
  Having a set of predefined components boosts your project development. The
  button is a basic block of an interface. Buttons can have lots of predefined
  properties and logic.
</p>
<h5 [id]="referenceAnchor">Reference</h5>
<p>This component relies on <a [routerLink]="idServicePath">idService</a>.</p>
